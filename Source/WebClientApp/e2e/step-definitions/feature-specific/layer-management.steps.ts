/**
 * Layer Management Step Definitions
 * GENERATED: 2025-10-12 (Phase 4 BDD Implementation)
 * FEATURE: Documents/Areas/Library/Features/SceneManagement/UseCases/ManageLayers/LayerManagement.feature
 * SERVICE: layerManager.ts
 * PHASE: EPIC-001 Phase 4 - Grid & Layers
 *
 * BDD steps for testing layer z-ordering, visibility management, and integration
 * with Konva Stage rendering pipeline.
 *
 * CRITICAL: Black-box testing - interacts through UI, verifies real behavior
 * ANTI-PATTERN: No step-to-step calls, no hard-coded credentials, no catch-all regex
 */

import { Given, When, Then, DataTable } from '@cucumber/cucumber';
import { CustomWorld } from '../../support/world.js';
import { expect } from '@playwright/test';

// ═══════════════════════════════════════════════════════════════
// GIVEN STEPS - Layer State Setup
// ═══════════════════════════════════════════════════════════════

Given('I have opened the scene editor', async function (this: CustomWorld) {
    // Navigate to scene editor page
    await this.page.goto('/library/scenes/editor');

    // Wait for scene editor to initialize
    await expect(this.page.locator('[data-testid="scene-editor"]')).toBeVisible({ timeout: 10000 });
});

Given('the Konva Stage is initialized', async function (this: CustomWorld) {
    // Wait for Konva Stage canvas element to be present
    await expect(this.page.locator('canvas[data-konva="stage"]')).toBeVisible({ timeout: 10000 });

    // Verify stage has initialized by checking for container
    const stageContainer = await this.page.locator('.konva-stage-container').count();
    expect(stageContainer).toBeGreaterThan(0);
});

Given('the background layer has an image', async function (this: CustomWorld) {
    // Simulate background image on background layer
    await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (stage) {
            const backgroundLayer = stage.findOne('.background');
            if (backgroundLayer) {
                const image = new (window as any).Konva.Image({
                    x: 0,
                    y: 0,
                    width: 800,
                    height: 600,
                    fill: '#cccccc'
                });
                backgroundLayer.add(image);
                backgroundLayer.batchDraw();
            }
        }
    });
});

Given('the grid layer has grid lines', async function (this: CustomWorld) {
    // Grid should render automatically when GridRenderer component mounts
    // Wait for grid lines to be present
    await this.page.waitForFunction(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const gridLayer = stage.findOne('.grid');
        return gridLayer && gridLayer.getChildren().length > 0;
    }, { timeout: 5000 });
});

Given('the agents layer has token images', async function (this: CustomWorld) {
    // Add token images to agents layer
    await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (stage) {
            const agentsLayer = stage.findOne('.agents');
            if (agentsLayer) {
                const token = new (window as any).Konva.Circle({
                    x: 100,
                    y: 100,
                    radius: 30,
                    fill: '#ff0000',
                    name: 'token'
                });
                agentsLayer.add(token);
                agentsLayer.batchDraw();
            }
        }
    });
});

Given('the scene has background, grid, and tokens', async function (this: CustomWorld) {
    // Composite setup - use helpers from previous steps
    await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return;

        // Background image
        const backgroundLayer = stage.findOne('.background');
        if (backgroundLayer) {
            const bgImage = new (window as any).Konva.Rect({
                x: 0, y: 0, width: 800, height: 600, fill: '#cccccc'
            });
            backgroundLayer.add(bgImage);
        }

        // Grid lines (should be rendered by GridRenderer)

        // Tokens
        const agentsLayer = stage.findOne('.agents');
        if (agentsLayer) {
            const token = new (window as any).Konva.Circle({
                x: 100, y: 100, radius: 30, fill: '#0000ff'
            });
            agentsLayer.add(token);
        }

        stage.batchDraw();
    });
});

Given('the ui layer has controls/overlays', async function (this: CustomWorld) {
    // Add UI elements to UI layer
    await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (stage) {
            const uiLayer = stage.findOne('.ui');
            if (uiLayer) {
                const controlButton = new (window as any).Konva.Rect({
                    x: 10,
                    y: 10,
                    width: 100,
                    height: 40,
                    fill: '#4caf50',
                    name: 'control-button'
                });
                uiLayer.add(controlButton);
                uiLayer.batchDraw();
            }
        }
    });
});

Given('the grid layer is visible', async function (this: CustomWorld) {
    // Ensure grid layer visibility is true
    const isVisible = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const gridLayer = stage.findOne('.grid');
        return gridLayer ? gridLayer.visible() : false;
    });

    if (!isVisible) {
        await this.page.evaluate(() => {
            const stage = (window as any).__konvaStage;
            const gridLayer = stage.findOne('.grid');
            if (gridLayer) {
                gridLayer.visible(true);
                stage.batchDraw();
            }
        });
    }
});

Given('the grid layer is hidden', async function (this: CustomWorld) {
    // Set grid layer visibility to false
    await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (stage) {
            const gridLayer = stage.findOne('.grid');
            if (gridLayer) {
                gridLayer.visible(false);
                stage.batchDraw();
            }
        }
    });
});

Given('all layers are visible', async function (this: CustomWorld) {
    // Set all layers to visible
    await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (stage) {
            const layers = stage.getLayers();
            layers.forEach((layer: any) => {
                layer.visible(true);
            });
            stage.batchDraw();
        }
    });
});

Given('layers have been manually reordered by some operation', async function (this: CustomWorld) {
    // Simulate manual layer reordering (break z-order)
    await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (stage) {
            const uiLayer = stage.findOne('.ui');
            const backgroundLayer = stage.findOne('.background');

            if (uiLayer && backgroundLayer) {
                // Move UI layer to bottom (wrong!)
                uiLayer.moveToBottom();
                // Move background to top (wrong!)
                backgroundLayer.moveToTop();
                stage.batchDraw();
            }
        }
    });
});

Given('layers have been modified \\(visibility changed, reordered\\)', async function (this: CustomWorld) {
    // Modify layers in various ways
    await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (stage) {
            const gridLayer = stage.findOne('.grid');
            const agentsLayer = stage.findOne('.agents');
            const uiLayer = stage.findOne('.ui');

            if (gridLayer) gridLayer.visible(false);
            if (agentsLayer) agentsLayer.visible(false);
            if (uiLayer) uiLayer.moveToBottom();

            stage.batchDraw();
        }
    });
});

Given('a Square grid is configured', async function (this: CustomWorld) {
    // Configure square grid (should be handled by GridRenderer component)
    await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (stage && (window as any).__gridRenderer) {
            (window as any).__gridRenderer.setGridType('square');
        }
    });
});

Given('a grid is rendered and visible', async function (this: CustomWorld) {
    // Ensure grid is rendered and visible
    await this.page.waitForFunction(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const gridLayer = stage.findOne('.grid');
        return gridLayer && gridLayer.visible() && gridLayer.getChildren().length > 0;
    }, { timeout: 5000 });
});

Given('the scene has all 7 layers with content', async function (this: CustomWorld) {
    // Add content to all 7 layers
    await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return;

        const layerNames = ['background', 'grid', 'structure', 'objects', 'agents', 'foreground', 'ui'];
        layerNames.forEach((name) => {
            const layer = stage.findOne(`.${name}`);
            if (layer) {
                const rect = new (window as any).Konva.Rect({
                    x: 0, y: 0, width: 50, height: 50, fill: '#cccccc'
                });
                layer.add(rect);
            }
        });
        stage.batchDraw();
    });
});

Given('each layer has {int}+ elements \\({int} total\\)', async function (
    this: CustomWorld,
    elementsPerLayer: number,
    _totalElements: number
) {
    // Add multiple elements to each layer
    await this.page.evaluate(({ perLayer, total: _total }) => {
        const stage = (window as any).__konvaStage;
        if (!stage) return;

        const layerNames = ['background', 'grid', 'structure', 'objects', 'agents', 'foreground', 'ui'];
        layerNames.forEach((name) => {
            const layer = stage.findOne(`.${name}`);
            if (layer) {
                for (let i = 0; i < perLayer; i++) {
                    const rect = new (window as any).Konva.Rect({
                        x: i * 10, y: i * 10, width: 20, height: 20, fill: '#aaa'
                    });
                    layer.add(rect);
                }
            }
        });
        stage.batchDraw();
    }, { perLayer: elementsPerLayer, total: _totalElements });
});

// ═══════════════════════════════════════════════════════════════
// WHEN STEPS - Layer Actions
// ═══════════════════════════════════════════════════════════════

When('the layer manager initializes', async function (this: CustomWorld) {
    // LayerManager initializes automatically when scene editor mounts
    // Wait for initialization to complete
    await this.page.waitForFunction(() => {
        return (window as any).__layerManager && (window as any).__layerManager.initialized;
    }, { timeout: 5000 });
});

When('the layerManager.enforceZOrder\\(\\) method is called', async function (this: CustomWorld) {
    // Call enforceZOrder method programmatically
    await this.page.evaluate(() => {
        const layerManager = (window as any).__layerManager;
        if (layerManager) {
            layerManager.enforceZOrder();
        }
    });
});

When('both layers render', async function (this: CustomWorld) {
    // Trigger batch draw
    await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (stage) {
            stage.batchDraw();
        }
    });

    // Wait for render to complete
    await this.page.waitForLoadState('networkidle');
});

When('all layers render', async function (this: CustomWorld) {
    // Trigger batch draw for all layers
    await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (stage) {
            stage.batchDraw();
        }
    });

    await this.page.waitForLoadState('networkidle');
});

When('I toggle grid layer visibility', async function (this: CustomWorld) {
    // Toggle grid visibility via UI control (button/checkbox)
    await this.page.click('[data-testid="toggle-grid-visibility"]');

    // Wait for toggle to apply
    await this.page.waitForLoadState('networkidle');
});

When('I hide the grid layer', async function (this: CustomWorld) {
    // Hide grid layer programmatically
    await this.page.evaluate(() => {
        const layerManager = (window as any).__layerManager;
        if (layerManager) {
            layerManager.setLayerVisibility('grid', false);
        }
    });
});

When('I hide the structure layer', async function (this: CustomWorld) {
    // Hide structure layer programmatically
    await this.page.evaluate(() => {
        const layerManager = (window as any).__layerManager;
        if (layerManager) {
            layerManager.setLayerVisibility('structure', false);
        }
    });
});

When('I call layerManager.setLayerVisibility\\({string}, {word}\\)', async function (
    this: CustomWorld,
    layerName: string,
    visibilityStr: string
) {
    const visible = visibilityStr === 'true';

    await this.page.evaluate(({ layer, vis }) => {
        const layerManager = (window as any).__layerManager;
        if (layerManager) {
            layerManager.setLayerVisibility(layer, vis);
        }
    }, { layer: layerName, vis: visible });
});

When('I query layerManager.getLayerStates\\(\\)', async function (this: CustomWorld) {
    // Store query result in world state
    this.currentAsset = await this.page.evaluate(() => {
        const layerManager = (window as any).__layerManager;
        return layerManager ? layerManager.getLayerStates() : null;
    });
});

When('I query layerManager.getLayer\\({string}\\)', async function (this: CustomWorld, layerName: string) {
    // Store layer instance reference in world state
    this.currentAsset = await this.page.evaluate((layer) => {
        const layerManager = (window as any).__layerManager;
        if (!layerManager) return null;

        const layerInstance = layerManager.getLayer(layer);
        return layerInstance ? { name: layerInstance.name(), visible: layerInstance.visible() } : null;
    }, layerName);
});

When('I initialize the layer manager with the Stage', async function (this: CustomWorld) {
    // Initialize layer manager with Konva Stage
    await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        const layerManager = (window as any).__layerManager;
        if (stage && layerManager) {
            layerManager.initialize(stage);
        }
    });
});

When('I call layerManager.reset\\(\\)', async function (this: CustomWorld) {
    // Reset layer manager to defaults
    await this.page.evaluate(() => {
        const layerManager = (window as any).__layerManager;
        if (layerManager) {
            layerManager.reset();
        }
    });
});

When('the GridRenderer component renders', async function (this: CustomWorld) {
    // GridRenderer should mount automatically
    // Wait for grid lines to appear on grid layer
    await this.page.waitForFunction(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const gridLayer = stage.findOne('.grid');
        return gridLayer && gridLayer.getChildren().length > 0;
    }, { timeout: 5000 });
});

When('I hide the grid layer via layerManager', async function (this: CustomWorld) {
    // Hide grid using layerManager service
    await this.page.evaluate(() => {
        const layerManager = (window as any).__layerManager;
        if (layerManager) {
            layerManager.setLayerVisibility('grid', false);
        }
    });
});

When('I toggle layer visibility', async function (this: CustomWorld) {
    // Toggle any layer visibility
    await this.page.evaluate(() => {
        const layerManager = (window as any).__layerManager;
        if (layerManager) {
            layerManager.toggleLayerVisibility('grid');
        }
    });
});

When('I call enforceZOrder\\(\\)', async function (this: CustomWorld) {
    // Measure performance of enforceZOrder
    const startTime = Date.now();

    await this.page.evaluate(() => {
        const layerManager = (window as any).__layerManager;
        if (layerManager) {
            layerManager.enforceZOrder();
        }
    });

    const endTime = Date.now();
    this.currentAsset = { duration: endTime - startTime };
});

// ═══════════════════════════════════════════════════════════════
// THEN STEPS - Layer Verification
// ═══════════════════════════════════════════════════════════════

Then('the layers should have the following z-order:', async function (this: CustomWorld, dataTable: DataTable) {
    const expectedOrder = dataTable.hashes();

    // Get actual z-order from stage
    const actualOrder = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return [];

        const layers = stage.getLayers();
        return layers.map((layer: any) => ({
            'Layer Name': layer.name(),
            'Z-Index': layer.zIndex()
        }));
    });

    // Verify each layer has correct z-index
    expectedOrder.forEach((expected, _index) => {
        const actual = actualOrder.find((a: any) => a['Layer Name'] === expected['Layer Name']);
        expect(actual).toBeDefined();
        expect(actual!['Z-Index']).toBe(parseInt(expected['Z-Index'] ?? '0'));
    });
});

Then('background should render first \\(bottom\\)', async function (this: CustomWorld) {
    const zIndex = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return -1;
        const bgLayer = stage.findOne('.background');
        return bgLayer ? bgLayer.zIndex() : -1;
    });

    expect(zIndex).toBe(0);
});

Then('ui should render last \\(top\\)', async function (this: CustomWorld) {
    const zIndex = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return -1;
        const uiLayer = stage.findOne('.ui');
        return uiLayer ? uiLayer.zIndex() : -1;
    });

    expect(zIndex).toBe(6);
});

Then('all layers should return to correct z-order', async function (this: CustomWorld) {
    // Verify z-order is correct for all layers
    const zOrders = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return null;

        const expected = {
            background: 0, grid: 1, structure: 2, objects: 3,
            agents: 4, foreground: 5, ui: 6
        };

        const actual: Record<string, number> = {};
        Object.keys(expected).forEach((name) => {
            const layer = stage.findOne(`.${name}`);
            if (layer) {
                actual[name] = layer.zIndex();
            }
        });

        return { expected, actual };
    });

    expect(zOrders).not.toBeNull();
    expect(zOrders!.actual).toEqual(zOrders!.expected);
});

Then('background should be behind all other layers', async function (this: CustomWorld) {
    const isBackgroundBottom = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const bgLayer = stage.findOne('.background');
        return bgLayer ? bgLayer.zIndex() === 0 : false;
    });

    expect(isBackgroundBottom).toBe(true);
});

Then('ui should be above all other layers', async function (this: CustomWorld) {
    const isUITop = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const uiLayer = stage.findOne('.ui');
        const maxZIndex = Math.max(...stage.getLayers().map((l: any) => l.zIndex()));
        return uiLayer ? uiLayer.zIndex() === maxZIndex : false;
    });

    expect(isUITop).toBe(true);
});

Then('the Stage should batch draw for performance', async function (this: CustomWorld) {
    // Verify batchDraw was called (check via event or flag)
    // This is verified implicitly - we can check that layers are rendered
    const isRendered = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        return stage && stage.getChildren().length > 0;
    });

    expect(isRendered).toBe(true);
});

Then('the background image should be visible', async function (this: CustomWorld) {
    const hasBackground = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const bgLayer = stage.findOne('.background');
        return bgLayer && bgLayer.visible() && bgLayer.getChildren().length > 0;
    });

    expect(hasBackground).toBe(true);
});

Then('the grid lines should appear on top of the background', async function (this: CustomWorld) {
    const zOrderCorrect = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const bgLayer = stage.findOne('.background');
        const gridLayer = stage.findOne('.grid');
        return bgLayer && gridLayer && gridLayer.zIndex() > bgLayer.zIndex();
    });

    expect(zOrderCorrect).toBe(true);
});

Then('the z-order should be: background \\({int}\\) < grid \\({int}\\)', async function (
    this: CustomWorld,
    bgZIndex: number,
    gridZIndex: number
) {
    const zOrders = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return null;
        return {
            background: stage.findOne('.background')?.zIndex() ?? -1,
            grid: stage.findOne('.grid')?.zIndex() ?? -1
        };
    });

    expect(zOrders).not.toBeNull();
    expect(zOrders!.background).toBe(bgZIndex);
    expect(zOrders!.grid).toBe(gridZIndex);
    expect(zOrders!.background).toBeLessThan(zOrders!.grid);
});

Then('grid lines should be visible', async function (this: CustomWorld) {
    const isGridVisible = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const gridLayer = stage.findOne('.grid');
        return gridLayer && gridLayer.visible() && gridLayer.getChildren().length > 0;
    });

    expect(isGridVisible).toBe(true);
});

Then('tokens should appear on top of grid lines', async function (this: CustomWorld) {
    const zOrderCorrect = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const gridLayer = stage.findOne('.grid');
        const agentsLayer = stage.findOne('.agents');
        return gridLayer && agentsLayer && agentsLayer.zIndex() > gridLayer.zIndex();
    });

    expect(zOrderCorrect).toBe(true);
});

Then('the z-order should be: grid \\({int}\\) < agents \\({int}\\)', async function (
    this: CustomWorld,
    gridZIndex: number,
    agentsZIndex: number
) {
    const zOrders = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return null;
        return {
            grid: stage.findOne('.grid')?.zIndex() ?? -1,
            agents: stage.findOne('.agents')?.zIndex() ?? -1
        };
    });

    expect(zOrders).not.toBeNull();
    expect(zOrders!.grid).toBe(gridZIndex);
    expect(zOrders!.agents).toBe(agentsZIndex);
    expect(zOrders!.grid).toBeLessThan(zOrders!.agents);
});

Then('the ui layer elements should be on top', async function (this: CustomWorld) {
    const isUIOnTop = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const uiLayer = stage.findOne('.ui');
        const maxZIndex = Math.max(...stage.getLayers().map((l: any) => l.zIndex()));
        return uiLayer && uiLayer.zIndex() === maxZIndex;
    });

    expect(isUIOnTop).toBe(true);
});

Then('ui should not be obscured by any other layer', async function (this: CustomWorld) {
    const isUIOnTop = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const uiLayer = stage.findOne('.ui');
        const layers = stage.getLayers();
        return uiLayer && layers.every((layer: any) =>
            layer.name() === 'ui' || layer.zIndex() < uiLayer.zIndex()
        );
    });

    expect(isUIOnTop).toBe(true);
});

Then('the grid layer should become hidden', async function (this: CustomWorld) {
    const isHidden = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const gridLayer = stage.findOne('.grid');
        return gridLayer ? !gridLayer.visible() : false;
    });

    expect(isHidden).toBe(true);
});

Then('the grid lines should not be visible on canvas', async function (this: CustomWorld) {
    const isVisible = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return true;
        const gridLayer = stage.findOne('.grid');
        return gridLayer ? gridLayer.visible() : true;
    });

    expect(isVisible).toBe(false);
});

Then('other layers should remain visible', async function (this: CustomWorld) {
    const otherLayersVisible = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;

        const otherLayers = ['background', 'structure', 'objects', 'agents', 'foreground', 'ui'];
        return otherLayers.every((name) => {
            const layer = stage.findOne(`.${name}`);
            return layer ? layer.visible() : false;
        });
    });

    expect(otherLayersVisible).toBe(true);
});

Then('the grid layer should become visible', async function (this: CustomWorld) {
    const isVisible = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const gridLayer = stage.findOne('.grid');
        return gridLayer ? gridLayer.visible() : false;
    });

    expect(isVisible).toBe(true);
});

Then('grid lines should reappear on canvas', async function (this: CustomWorld) {
    const isVisible = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const gridLayer = stage.findOne('.grid');
        return gridLayer && gridLayer.visible() && gridLayer.getChildren().length > 0;
    });

    expect(isVisible).toBe(true);
});

Then('the grid configuration should be preserved', async function (this: CustomWorld) {
    // Verify grid config hasn't changed after hide/show
    const hasGridConfig = await this.page.evaluate(() => {
        const gridRenderer = (window as any).__gridRenderer;
        return gridRenderer && gridRenderer.config !== null;
    });

    expect(hasGridConfig).toBe(true);
});

Then('grid and structure should be hidden', async function (this: CustomWorld) {
    const areHidden = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const gridLayer = stage.findOne('.grid');
        const structureLayer = stage.findOne('.structure');
        return !gridLayer?.visible() && !structureLayer?.visible();
    });

    expect(areHidden).toBe(true);
});

Then('background, objects, agents should remain visible', async function (this: CustomWorld) {
    const areVisible = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const bgLayer = stage.findOne('.background');
        const objectsLayer = stage.findOne('.objects');
        const agentsLayer = stage.findOne('.agents');
        return bgLayer?.visible() && objectsLayer?.visible() && agentsLayer?.visible();
    });

    expect(areVisible).toBe(true);
});

Then('layer z-order should be maintained', async function (this: CustomWorld) {
    const isCorrectOrder = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;

        const expected = { background: 0, grid: 1, structure: 2, objects: 3, agents: 4, foreground: 5, ui: 6 };
        return Object.entries(expected).every(([name, zIndex]) => {
            const layer = stage.findOne(`.${name}`);
            return layer ? layer.zIndex() === zIndex : false;
        });
    });

    expect(isCorrectOrder).toBe(true);
});

Then('the grid layer should be hidden', async function (this: CustomWorld) {
    const isHidden = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        const gridLayer = stage?.findOne('.grid');
        return gridLayer ? !gridLayer.visible() : false;
    });

    expect(isHidden).toBe(true);
});

Then('the grid layer should be visible', async function (this: CustomWorld) {
    const isVisible = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        const gridLayer = stage?.findOne('.grid');
        return gridLayer ? gridLayer.visible() : false;
    });

    expect(isVisible).toBe(true);
});

Then('I should receive an array of {int} layer states', async function (this: CustomWorld, count: number) {
    const layerStates = this.currentAsset;
    expect(layerStates).toBeDefined();
    expect(Array.isArray(layerStates)).toBe(true);
    expect(layerStates.length).toBe(count);
});

Then('each state should contain: name, visible, zIndex', async function (this: CustomWorld) {
    const layerStates = this.currentAsset;
    expect(Array.isArray(layerStates)).toBe(true);

    layerStates.forEach((state: any) => {
        expect(state).toHaveProperty('name');
        expect(state).toHaveProperty('visible');
        expect(state).toHaveProperty('zIndex');
    });
});

Then('states should be sorted by z-index ascending', async function (this: CustomWorld) {
    const layerStates = this.currentAsset;
    expect(Array.isArray(layerStates)).toBe(true);

    for (let i = 1; i < layerStates.length; i++) {
        expect(layerStates[i].zIndex).toBeGreaterThanOrEqual(layerStates[i - 1].zIndex);
    }
});

Then('I should receive the Konva Layer instance for grid', async function (this: CustomWorld) {
    const layerData = this.currentAsset;
    expect(layerData).toBeDefined();
    expect(layerData.name).toBe('grid');
});

Then('the layer should have name {string}', async function (this: CustomWorld, expectedName: string) {
    const layerData = this.currentAsset;
    expect(layerData).toBeDefined();
    expect(layerData.name).toBe(expectedName);
});

Then('all {int} default layers should be initialized', async function (this: CustomWorld, count: number) {
    const layerCount = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        return stage ? stage.getLayers().length : 0;
    });

    expect(layerCount).toBe(count);
});

Then('each layer should have correct initial visibility \\(true\\)', async function (this: CustomWorld) {
    const allVisible = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const layers = stage.getLayers();
        return layers.every((layer: any) => layer.visible() === true);
    });

    expect(allVisible).toBe(true);
});

Then('each layer should have correct z-index', async function (this: CustomWorld) {
    const hasCorrectZIndex = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;

        const expected = { background: 0, grid: 1, structure: 2, objects: 3, agents: 4, foreground: 5, ui: 6 };
        return Object.entries(expected).every(([name, zIndex]) => {
            const layer = stage.findOne(`.${name}`);
            return layer ? layer.zIndex() === zIndex : false;
        });
    });

    expect(hasCorrectZIndex).toBe(true);
});

Then('all layers should return to default visibility \\(all visible\\)', async function (this: CustomWorld) {
    const allVisible = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const layers = stage.getLayers();
        return layers.every((layer: any) => layer.visible() === true);
    });

    expect(allVisible).toBe(true);
});

Then('all layers should return to default z-order', async function (this: CustomWorld) {
    const hasCorrectZOrder = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;

        const expected = { background: 0, grid: 1, structure: 2, objects: 3, agents: 4, foreground: 5, ui: 6 };
        return Object.entries(expected).every(([name, zIndex]) => {
            const layer = stage.findOne(`.${name}`);
            return layer ? layer.zIndex() === zIndex : false;
        });
    });

    expect(hasCorrectZOrder).toBe(true);
});

Then('grid lines should be drawn on the {string} layer', async function (this: CustomWorld, layerName: string) {
    const hasGridLines = await this.page.evaluate((name) => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const layer = stage.findOne(`.${name}`);
        return layer && layer.getChildren().length > 0;
    }, layerName);

    expect(hasGridLines).toBe(true);
});

Then('the grid layer should have z-index {int}', async function (this: CustomWorld, expectedZIndex: number) {
    const actualZIndex = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return -1;
        const gridLayer = stage.findOne('.grid');
        return gridLayer ? gridLayer.zIndex() : -1;
    });

    expect(actualZIndex).toBe(expectedZIndex);
});

Then('grid should appear above background \\({int}\\) and below structure \\({int}\\)', async function (
    this: CustomWorld,
    bgZIndex: number,
    structureZIndex: number
) {
    const zOrders = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return null;
        return {
            background: stage.findOne('.background')?.zIndex() ?? -1,
            grid: stage.findOne('.grid')?.zIndex() ?? -1,
            structure: stage.findOne('.structure')?.zIndex() ?? -1
        };
    });

    expect(zOrders).not.toBeNull();
    expect(zOrders!.background).toBe(bgZIndex);
    expect(zOrders!.structure).toBe(structureZIndex);
    expect(zOrders!.grid).toBeGreaterThan(zOrders!.background);
    expect(zOrders!.grid).toBeLessThan(zOrders!.structure);
});

Then('the GridRenderer should not be visible', async function (this: CustomWorld) {
    const isHidden = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return true;
        const gridLayer = stage.findOne('.grid');
        return gridLayer ? !gridLayer.visible() : true;
    });

    expect(isHidden).toBe(true);
});

Then('the grid layer should still exist \\(just hidden\\)', async function (this: CustomWorld) {
    const layerExists = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;
        const gridLayer = stage.findOne('.grid');
        return gridLayer !== undefined && gridLayer !== null;
    });

    expect(layerExists).toBe(true);
});

Then('showing the layer again should restore grid visibility', async function (this: CustomWorld) {
    // Show layer
    await this.page.evaluate(() => {
        const layerManager = (window as any).__layerManager;
        if (layerManager) {
            layerManager.setLayerVisibility('grid', true);
        }
    });

    // Verify visibility restored
    const isVisible = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        const gridLayer = stage?.findOne('.grid');
        return gridLayer ? gridLayer.visible() : false;
    });

    expect(isVisible).toBe(true);
});

Then('the operation should complete in less than {int}ms', async function (this: CustomWorld, maxDuration: number) {
    const duration = this.currentAsset?.duration ?? 0;
    expect(duration).toBeLessThan(maxDuration);
});

Then('the Stage should batch draw efficiently', async function (this: CustomWorld) {
    // Verify batchDraw was used (not individual draw calls)
    // This is implicit - check that rendering completed
    const isRendered = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        return stage !== null && stage !== undefined;
    });

    expect(isRendered).toBe(true);
});

Then('all elements should maintain correct z-order', async function (this: CustomWorld) {
    const isCorrectOrder = await this.page.evaluate(() => {
        const stage = (window as any).__konvaStage;
        if (!stage) return false;

        const expected = { background: 0, grid: 1, structure: 2, objects: 3, agents: 4, foreground: 5, ui: 6 };
        return Object.entries(expected).every(([name, zIndex]) => {
            const layer = stage.findOne(`.${name}`);
            return layer ? layer.zIndex() === zIndex : false;
        });
    });

    expect(isCorrectOrder).toBe(true);
});
